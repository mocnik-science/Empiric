<!DOCTYPE html>
<html>
  <meta>
    <title>Empirical Study | Step {{step}}</title>
    <script src="{{url_for('static', filename='libs/jquery/dist/jquery.min.js')}}"></script>
    <link rel="stylesheet" href="{{url_for('static', filename='libs/leaflet/dist/leaflet.css')}}"/>
    <script src="{{url_for('static', filename='libs/leaflet/dist/leaflet.js')}}"></script>
    <link rel="stylesheet" href="{{url_for('static', filename='libs/leaflet-draw/dist/leaflet.draw.css')}}"/>
    <script src="{{url_for('static', filename='libs/leaflet-draw/dist/leaflet.draw.js')}}"></script>
    <script src="{{url_for('static', filename='libs/leaflet-path-transform/dist/L.Path.Transform.js')}}"></script>
    <style>
      html {
        font-size: 62.5%;
      }
      body {
        overscroll-behavior: none;
        background: #000;
        font-family: 'Helvetica', sans-serif;
      }
      a {
        color: #2980B9;
        text-decoration: none;
      }
      #nextStepButton {
        display: none;
        position: absolute;
        z-index: 1000;
        top: 0;
        right: 0;
        background: #ddd;
      }
      #nextStepButton a {
        display: inline-block;
        padding: 1.5rem 3rem;
        font-size: 3rem;
      }
      #map {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: #000;
      }
    </style>
    <script>
      jQuery(function($) {
        const DRAW_GEOMETRIES = 'DRAW_GEOMETRIES'
        const TRANSFORM_GEOMETRIES = 'TRANSFORM_GEOMETRIES'
        const step = {{step}}
        $(window).ready(() => {
          $.getJSON('{{url_for('settings', step=step)}}').done(settings => {
            // COLOURS
            const color = name => {
              if (name == 'RED') return '#E74C3C'
              if (name == 'PURPLE') return '#9B59B6'
              if (name == 'BLUE') return '#3498DB'
              if (name == 'GREEN') return '#2ECC71'
              if (name == 'YELLOW') return '#F1C40F'
              if (name == 'ORANGE') return '#F39C12'
              if (name == 'GRAY') return '#C3C3C3'
            }
            // STYLE
            const styleDrawn = c => ({
              stroke: true,
              color: color(c),
              weight: 4,
              opacity: .75,
              fill: true,
              fillOpacity: .6,
            })
            const styleDrawing = c => Object.assign(styleDrawn(c), {
              fill: false,
            })
            // DATA
            const data = {
              log: [],
            }
            const logging = (message, d) => {
              data.log.push({
                timestamp: new Date().toISOString(),
                message: message,
                d: d,
              })
            }
            // NEXT STEP
            const saveAndNext = () => {
              if (settings.task == TRANSFORM_GEOMETRIES) data.geometries = settings.geometries
              $.ajax({
                url: '{{url_for('save', step=step)}}',
                type: 'POST',
                dataType: 'json',
                contentType: 'application/json; charset=utf-8',
                data: JSON.stringify(data),
              }).done(() => {
                window.location.assign('{{url_for('step')}}')
              })
            }
            $('#nextStepButton a').on('click', e => {
              e.preventDefault()
              saveAndNext()
            })
            const nextStep = () => {
              setTimeout(() => {
                $('#map').css('display', 'none')
                setTimeout(() => {
                  saveAndNext()
                }, settings.waitAfterLastDraw)
              }, settings.waitBeforeNext)
            }
            const nextStepShow = () => {
              $('#nextStepButton').css('display', 'block')
            }
            // COMPUTE SIZE
            const size = settings.backgroundImageSize
            const fillHeight = (size.height / size.width > window.innerHeight / window.innerWidth)
            const height = (fillHeight) ? window.innerHeight : size.height / size.width * window.innerWidth
            const width = (fillHeight) ? size.width / size.height * window.innerHeight : window.innerWidth
            const scale = (fillHeight) ? window.innerHeight / size.height : window.innerWidth / size.width
            const bounds = [[0, 0], [height, width]]
            // PROJECTION
            const layerToGeoJSON = layer => unproject(layer.toGeoJSON())
            const project = gj => {
              gj = JSON.parse(JSON.stringify(gj))
              gj.geometry.coordinates[0] = gj.geometry.coordinates[0].map(([x, y]) => [x * scale, y * scale])
              return gj
            }
            const unproject = gj => {
              gj = JSON.parse(JSON.stringify(gj))
              gj.geometry.coordinates[0] = gj.geometry.coordinates[0].map(([x, y]) => [x / scale, y / scale])
              return gj
            }
            class GeoJSON {
              static type(gj) {
                return gj.geometry.type
              }
              static toCoordinates(gj) {
                return gj.geometry.coordinates[0].map(([x, y]) => [y, x])
              }
              static centroid(gj) {
                let x = 0
                let y = 0
                const n = gj.geometry.coordinates[0].length
                for (const c of gj.geometry.coordinates[0]) {
                  x += c[0]
                  y += c[1]
                }
                return [x / n, y / n]
              }
              static translate(gj, shift) {
                gj = JSON.parse(JSON.stringify(gj))
                gj.geometry.coordinates[0] = gj.geometry.coordinates[0].map(([x, y]) => [x + shift[0], y + shift[1]])
                return gj
              }
              static scale(gj, scale) {
                if (typeof(scale) == 'number') scale = [scale, scale]
                const centroid = GeoJSON.centroid(gj)
                const translated = GeoJSON.translate(gj, [-centroid[0], -centroid[1]])
                translated.geometry.coordinates[0] = translated.geometry.coordinates[0].map(([x, y]) => [scale[0] * x, scale[1] * y])
                return GeoJSON.translate(translated, centroid)
              }
              static rotate(gj, angle) {
                const centroid = GeoJSON.centroid(gj)
                const translated = GeoJSON.translate(gj, [-centroid[0], -centroid[1]])
                const sinAngle = Math.sin(angle)
                const cosAngle = Math.cos(angle)
                translated.geometry.coordinates[0] = translated.geometry.coordinates[0].map(([x, y]) => [cosAngle * x - sinAngle * y, sinAngle * x + cosAngle * y])
                return GeoJSON.translate(translated, centroid)
              }
            }
            // MAP
            const map = L.map('map', {
              crs: L.CRS.Simple,
              zoomSnap: 0,
              doubleClickZoom: false,
              dragging: false,
              keyboard: false,
              scrollWheelZoom: false,
              touchZoom: false,
              attributionControl: false,
              zoomControl: false,
              minZoom: 0,
              maxZoom: 18,
            }).fitBounds(bounds)
            // IMAGE
            L.imageOverlay(`{{url_for('static', filename='files/')}}${settings.backgroundImage}`, bounds).addTo(map)
            // GEOMETRIES
            if (settings.geometries) {
              settings.geometries = settings.geometries.map(geometry => (geometry.filename !== undefined) ? geometry : {filename: geometry})
              settings.geometries.map(geometry => {
                $.getJSON(`{{url_for('static', filename='files/')}}${geometry.filename}`).done(g => {
                  if (GeoJSON.type(g) == 'Polygon') {
                    if (geometry.translate) g = GeoJSON.translate(g, geometry.translate)
                    if (geometry.scale) g = GeoJSON.scale(g, geometry.scale)
                    if (geometry.rotate) g = GeoJSON.rotate(g, geometry.rotate)
                    const layer = L.polygon(GeoJSON.toCoordinates(project(g)), {
                      ...styleDrawn(settings.geometriesColor),
                      transform: settings.transformRotate || settings.transformResize || settings.transformResizeNonUniform,
                      draggable: settings.transformTranslate,
                    }).addTo(map)
                    // TRANSFORM GEOMETRIES
                    if (settings.task == TRANSFORM_GEOMETRIES) layer.transform.enable({
                      rotation: settings.transformRotate,
                      scaling: settings.transformResize || settings.transformResizeNonUniform,
                      uniformScaling: !settings.transformResizeNonUniform,
                    })
                    if (settings.transformTranslate) layer.dragging.enable()
                    if (settings.task == TRANSFORM_GEOMETRIES) {
                      layer.on('rotateend', e => {
                        map.dragging.disable()
                        if (geometry.userRotate === undefined) geometry.userRotate = 0
                        geometry.userRotate += e.rotation
                        logging('geometry rotated', {
                            geometry: geometry.filename,
                            userRotate: geometry.userRotate,
                          })
                      })
                      layer.on('transformed', e => {
                        map.dragging.disable()
                        if (e.scale && (e.scale.x != 1 || e.scale.y != 1)) {
                          if (geometry.userScale === undefined) geometry.userScale = [1, 1]
                          geometry.userScale = [geometry.userScale[0] * e.scale.x, geometry.userScale[1] * e.scale.y]
                          logging('geometry scaled', {
                            geometry: geometry.filename,
                            userScale: geometry.userScale,
                          })
                        }
                        if (e.translate) {
                          if (geometry.userTranslate === undefined) geometry.userTranslate = [0, 0]
                          geometry.userTranslate = [geometry.userTranslate[0] + e.translate.x / scale, geometry.userTranslate[1] - e.translate.y / scale]
                          logging('geometry translated', {
                            geometry: geometry.filename,
                            userTranslate: geometry.userTranslate,
                          })
                        }
                      })
                    }
                  } else L.geoJSON(project(g), {
                    style: styleDrawn(settings.geometriesColor),
                  }).addTo(map)
                })
              })
            }
            // DRAW GEOMETRIES
            if (settings.task == DRAW_GEOMETRIES) {
              let drawCount = settings.drawCount
              const startDrawing = () => {
                new L.Draw.Polygon(map, {
                  shapeOptions: styleDrawing(settings.drawColor),
                }).enable()
              }
              map.on(L.Draw.Event.CREATED, e => {
                logging('geometry drawn', layerToGeoJSON(e.layer))
                if (data.geometries === undefined) data.geometries = []
                data.geometries.push(layerToGeoJSON(e.layer))
                map.addLayer(e.layer)
                e.layer.setStyle(styleDrawn(settings.drawColor))
                if (drawCount == null) {
                  startDrawing()
                  nextStepShow()
                } else {
                  drawCount -= 1
                  if (drawCount > 0) startDrawing()
                  else nextStep()
                }
              })
              startDrawing()
            }
            // TRANSFORM GEOMETRIES
            if (settings.task == TRANSFORM_GEOMETRIES) nextStepShow()
          })
        })
      })
    </script>
  </meta>
  <body>
    <div id="nextStepButton"><a id="x" href="">Next Step</a></div>
    <div id="map"></div>
  </body>
</html>
